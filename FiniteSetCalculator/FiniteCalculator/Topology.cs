#region Using directives

using System;
using System.Collections.Generic;
using System.Text;

#endregion

namespace FiniteCalculator {



    /// <summary>
    /// Represents a topology.  A topology is a subset of the powerset which is closed under intersection and union
    /// of any two of its members and also contains the empty and basis sets.
    /// </summary>
    public class Topology : IComparable<Topology> {



        /// <summary>
        /// Constructor, for Powerset to use.
        /// </summary>
        /// <param name="size">
        /// The basis set size.
        /// </param>
        protected Topology(int size) {
            elements = new List<Set>[size + 1];
            for (int i = 0; i < size + 1; i++) {
                elements[i] = new List<Set>();
            }
        }



        /// <summary>
        /// Constructs the minimal topology given a powerset.
        /// </summary>
        /// <param name="powerset">
        /// Powerset to construct the topology from.
        /// </param>
        /// <remarks>
        /// The minimal topology contains the empty set and the basis.
        /// </remarks>
        public Topology(PowerSet powerset) {
            this.powerset = powerset;
            int length = powerset.elements.Length;
            elements = new List<Set>[length];
            for (int i = 0; i < length; i++) {
                elements[i] = new List<Set>();
            }
            elements[0].Add(powerset.Elements[0][0]);
            elements[length - 1].Add(powerset.Elements[length - 1][0]);
            this.size = 2;
        }



        /// <summary>
        /// Our reference to the power set this topology is a subset of.
        /// </summary>
        protected PowerSet powerset;



        /// <summary>
        /// Applies the minimal permutation updating the actual data.
        /// </summary>
        public void ReMin() {
            for (int i = 1; i < elements.Length - 1; i++) {
                for (int j = 0; j < elements[i].Count; j++) {
                    elements[i][j] = powerset.PermuteSet(elements[i][j], min);
                }
            }
            min = 0;
        }



        /// <summary>
        /// Adds a set to the topology, also adding all required other sets to make the result
        /// also a topology.
        /// </summary>
        /// <param name="toAdd">
        /// The set to add.
        /// </param>
        /// <returns>
        /// -1 if the set is already a member of the topology.
        /// 0 if adding was successful.
        /// 1 if adding to the set resulted in a violation of the top level ordering constraints.
        /// </returns>
        /// <remarks>
        /// When adding a set to the system, if it causes another set to be added which is prior to the
        /// originally added set, then the resultant topology has either a) already been generated
        /// or b) can be generated by adding the original set to one which has already been generated.
        /// Additionally, Any attempt to add a set of size one such that the resultant sets of size 1
        /// within the topology are not minimal, is ignored, since any such resultant topology will
        /// be minimalised to one which would otherwise already be generated.
        /// Therefore both such events cause this method to fail.
        /// </remarks>
        public int AddProper(Set toAdd) {
            return AddProper(toAdd, toAdd.num);
        }


        /// <summary>
        /// Adds a set to a topology.  Recursively adding additionally needed sets.
        /// </summary>
        /// <param name="toAdd">
        /// Set to add to the topology.
        /// </param>
        /// <param name="current">
        /// The number of the original set added, which sparked the recursive chain.
        /// </param>
        /// <returns>
        /// -1 if the set is already a member of the topology.
        /// 0 if adding was successful.
        /// 1 if adding to the set resulted in a violation of the top level ordering constraints.
        /// </returns>
        private int AddProper(Set toAdd, int current) {

            // Find where to insert it/if its already inserted.
            int num = toAdd.num;
            int index = elements[toAdd.Size].BinarySearch(toAdd);
            if (index >= 0)
                return -1;
            index = ~index;

            // Early exit if set to be added is prior to the original set.
            if (num < current)
                return 1;

            // Ignore set adds which cause non-minimal size-one section.
            if (toAdd.Size == 1) {
                if (num != elements[toAdd.Size].Count + 1) {
                    return 1;
                }
            }

            // Add the set.
            if (index >= elements[toAdd.Size].Count)
                elements[toAdd.Size].Add(toAdd);
            else
                elements[toAdd.Size].Insert(index, toAdd);
            size++;

            // Check each existing member for union/intersection.
            // skip empty/basis sets as they wont add anything other then themselves.
            for (int i = 1; i < elements.Length - 1; i++) {
                index = 0;
                for (; index < elements[i].Count; index++) {
                    Set testSet = elements[i][index];
                    int res = 0;
                    res = AddProper(powerset.IntersectSets(toAdd, testSet), current);
                    if (res > 0)
                        return 1;
                    res = 0;
                    res = AddProper(powerset.UnionSets(toAdd, testSet), current);
                    if (res > 0)
                        return 1;
                }

            }
            return 0;
        }



        /// <summary>
        /// Trys a potential permutation to see if it improves things.
        /// </summary>
        /// <param name="inTopol">
        /// Original topology.
        /// </param>
        /// <param name="pairswap">
        /// Permutation to try.
        /// </param>
        /// <returns>
        /// A new topolgy if its 'more minimal' then the original.
        /// Null otherwise.
        /// </returns>
        private Topology TryMin(Topology inTopol, int pairswap) {
            Topology duplicate = inTopol.Copy();
            duplicate.min = pairswap;
            for (int i = 1; i < duplicate.elements.Length - 1; i++)
                duplicate.elements[i].Sort(new SetPermComparer(duplicate.min, powerset));
            duplicate.ReMin();
            if (duplicate.CompareTo(inTopol) >= 0)
                return null;
            return duplicate;
        }



        /// <summary>
        /// This algorithm doesnt gaurantee minimisation, but it will minimise alot of cases.
        /// </summary>
        /// <param name="pairswaps">
        /// An array of permutations which perform pair swapping.
        /// </param>
        /// <remarks>
        /// Was trying to use this to speed up the code, but alas it slowed it down.
        /// Using it instead of Min - fails due to this function not being able to minimise
        /// {{} {1,2} {3,4} {3,4,5} {1,2,3,4} {1,2,3,4,5}} and other similar cases.
        /// </remarks>
        public void PreMin(int[] pairswaps) {
            Topology duplicate = Copy();
            Topology minimum = duplicate;
            int lastSuccess = -1;
            for (int i = 0; i < pairswaps.Length; i++) {
                if (i == lastSuccess)
                    continue;
                Topology newTopol = TryMin(minimum, pairswaps[i]);
                if (newTopol != null) {
                    lastSuccess = i;
                    i = 0;
                    minimum = newTopol;
                }

            }
            CopyBack(minimum);
        }


        /// <summary>
        /// Set up elements3.
        /// </summary>
        private List<Set>[] Transfer() {
            List<Set>[] elements3 = new List<Set>[elements.Length];
            elements3[0] = new List<Set>();
            elements3[0].Add(elements[0][0]);
            elements3[elements.Length - 1] = new List<Set>();
            elements3[elements.Length - 1].Add(elements[elements.Length - 1][0]);
            for (int i = 1; i < elements.Length - 1; i++) {
                elements3[i] = new List<Set>();
                for (int j = 0; j < elements[i].Count; j++) {
                    if (elements[i][j].elements[elements[i][j].Size - 1] > elements[1].Count)
                        elements3[i].Add(elements[i][j]);
                }
            }
            return elements3;
        }



        /// <summary>
        /// Does a single sorting pass.
        /// </summary>
        /// <param name="trymin">
        /// List of sets to sort.
        /// </param>
        /// <param name="by">
        /// The permutation to perform the sorting under.
        /// </param>
        /// <param name="limit">
        /// The size of the part of the list being sorted.
        /// </param>
        /// <param name="loop">
        /// Stores which loop this is.
        /// </param>
        /// <returns>
        /// True if anything moved.
        /// False otherwise.
        /// </returns>
        private bool sortpass2(List<Set> trymin, int by, int limit, int loop) {
            bool changed = false;
            for (int i = limit - 1; i > loop; i--) {
                int index1 = powerset.PermutationsIndex[by, trymin[i].num];
                int index2 = powerset.PermutationsIndex[by, trymin[i - 1].num];
                if (index1 < index2) {
                    Set temp = trymin[i];
                    trymin[i] = trymin[i - 1];
                    trymin[i - 1] = temp;
                    changed = true;
                }
            }
            return changed;
        }



        /// <summary>
        /// Find the minimal permutation for this set.
        /// </summary>
        /// <returns>
        /// True if minimisation occured and we should proceed.
        /// False if it was determined that there is no point proceeding.
        /// </returns>
        public bool Minimize() {
            // Two arrays to store the successful permutation set so far
            int[] old = new int[powerset.FactorialSize + 1];
            // and the ones which worked for the current size.
            int[] next = new int[powerset.FactorialSize + 1];

            // Only sets containing numbers higher than the size 1 sets are relevent for the minimisation process.
            // Since all combinations of the unions of the sets if size 1 exist, and all minimal permutations
            // are constrained to map the sets of size 1 in between each other, their unions will all map between 
            // each other as well.  Comming into this function the sets of size 1 are already minimal 
            // due to the minimialization constraint in AddProper.
            List<Set>[] elements3 = Transfer();
            int howmany = elements[1].Count;
            int i2 = 0;

            // Retrieve the precalculated permutations which are constrained to map sets of size 1 between themselves.
            int value = powerset.StartPoint[howmany, i2];
            while (value >= 0) {
                old[i2] = value;
                i2++;
                value = powerset.StartPoint[howmany, i2];
            }
            old[i2] = -1;

            // Iterate over all of the sizes of sets in the topology.
            for (int i = 1; i < elements.Length - 1 && old[1] != -1; i++) {
                // no sets, nothing to do.
                if (elements3[i].Count == 0)
                    continue;

                // construct a list of sets to try each permutation of the relevent sets of this size.
                // Need this so that it can be sorted and compare with the previous best
                // which will be kept in elements3.
                List<Set> trymin = new List<Set>();
                // Sort elements3, based on the current best permutation.
                elements3[i].Sort(new SetPermComparer(old[0], powerset));
                // Copy into trymin.
                for (int j = 0; j < elements3[i].Count; j++) {
                    trymin.Add(elements3[i][j]);
                }

                next[0] = old[0];
                int nex = 1;
                int cur = 1;
                // Check each of the current best to see if they minimialize the new list of sets.
                while (old[cur] != -1) {
                    int k = 0;
                    int ans = 0;
                    int oldCur = old[cur];
                    int nextZero = next[0];
                    List<Set> elements3i = elements3[i];
                    // Use single bubble sort passes to allow early out as each node bubbles to the top.
                    while (ans == 0 && sortpass2(trymin, oldCur, elements3i.Count, k)) {
                        int index1 = powerset.PermutationsIndex[nextZero, elements3i[k].num];
                        int index2 = powerset.PermutationsIndex[oldCur, trymin[k].num];
                        ans = Math.Sign(index1 - index2);
                        k++;
                    }
                    // If sorting exist early, check the rest
                    while (ans == 0 && k < elements3i.Count) {
                        // Compare with previous best.
                        int index1 = powerset.PermutationsIndex[nextZero, elements3i[k].num];
                        int index2 = powerset.PermutationsIndex[oldCur, trymin[k].num];
                        ans = Math.Sign(index1 - index2);
                        k++;
                    }
                    // As good as preious best, add it to the list.
                    if (ans == 0) {
                        next[nex] = old[cur];
                        nex++;
                    }
                    else if (ans == 1) {
                        // Better then previous best, start a new list.
                        next[0] = old[cur];
                        nex = 1;
                        // Try early out.  CheckAdd is an option here instead of check.
                        /*
                        for (int j = 1; j < elements.Length - 1; j++)
                            elements[j].Sort(new SetPermComparer(next[0], powerset));
                        if (!FiniteTopologyGenerator.Check(this)) {
                            return false;
                        }
                        */
                        // Finish sorting incase we earlied out.
                        trymin.Sort(k, trymin.Count - k, new SetPermComparer(old[cur], powerset));
                        // Switch trymin with previous minimal, avoiding copy.
                        List<Set> temp = elements3[i];
                        elements3[i] = trymin;
                        trymin = temp;

                    }
                    cur++;
                }
                next[nex] = -1;
                // Switch old with new (avoids array copy of potentially large array).
                int[] tempInt = old;
                old = next;
                next = tempInt;

                // This is an attempt at an early out by comparing current minimum with existing minimums.
                // No noticible speed increase.
                /*
                min = old[0];
                for (int j = 1; j < elements.Length - 1; j++)
                    elements[j].Sort(new SetPermComparer(min, powerset));
                if (!FiniteTopologyGenerator.Check(this)) {
                    return false;
                }
                */
            }
            // Ensure the real elements are sorted correctly for the minimal permutation.
            min = old[0];
            for (int i = 1; i < elements.Length - 1; i++)
                elements[i].Sort(new SetPermComparer(min, powerset));
            return true;
        }



        /// <summary>
        /// Gets the elements of the topology, as an array of lists, grouping by element size.
        /// </summary>
        /// <value></value>
        public List<Set>[] Elements {
            get {
                return elements;
            }
        }
        protected List<Set>[] elements;



        /// <summary>
        /// Gets the size of the topology.
        /// </summary>
        /// <value></value>
        public int Size {
            get {
                return size;
            }
        }
        protected int size;



        /// <summary>
        /// Gets the minimal permutation.  
        /// Is zero if either a) topology is minimal or b) minimization has not been attempted yet.
        /// </summary>
        /// <value></value>
        public int Min {
            get {
                return min;
            }
        }
        public int min;



        /// <summary>
        /// Gets the number of duplicates of this set which have been found so far.
        /// </summary>
        /// <value></value>
        public int Duplicates {
            get {
                return duplicates;
            }
        }
        public int duplicates;



        /// <summary>
        /// Copies this topology into a new one.
        /// </summary>
        /// <returns>
        /// A copy of this topology.
        /// </returns>
        public Topology Copy() {
            Topology result = new Topology(powerset);
            for (int i = 1; i < elements.Length - 1; i++) {
                result.elements[i].AddRange(elements[i]);
            }
            result.size = size;
            result.min = min;
            return result;
        }



        /// <summary>
        /// Makes this topology a copy of another.
        /// </summary>
        /// <param name="from">
        /// The topology to copy.
        /// </param>
        public void CopyBack(Topology from) {
            for (int i = 1; i < elements.Length - 1; i++) {
                elements[i].Clear();
                elements[i].AddRange(from.elements[i]);
            }
            size = from.size;
            min = from.min;
        }



        #region IComparable<Topology> Members



        /// <summary>
        /// Compares this topology to another.
        /// </summary>
        /// <param name="other">
        /// The other topology to compare to.
        /// </param>
        /// <returns>
        /// A number representing if this topology is greater then the other.
        /// </returns>
        /// <remarks>
        /// Uses minimal permutations for the comparison, if they are present.
        /// </remarks>
        public int CompareTo(Topology other) {
            int elementsLength = elements.Length;
            for (int i = 1; i < elementsLength - 1; i++) {
                int ans = Math.Sign(elements[i].Count - other.elements[i].Count);
                if (ans != 0)
                    return ans;
            }
            if (min != 0 || other.min != 0) {
                for (int i = 1; i < elementsLength - 1; i++) {
                    List<Set> elementsi = elements[i];
                    List<Set> otherelementsi = other.elements[i];
                    int elementsiCount = elementsi.Count;
                    for (int j = 0; j < elementsiCount; j++) {
                        int index1 = powerset.PermutationsIndex[min, elementsi[j].num];
                        int index2 = powerset.PermutationsIndex[other.min, otherelementsi[j].num];
                        int ans = Math.Sign(index1 - index2);
                        if (ans != 0)
                            return ans;
                    }
                }
            }
            else {
                for (int i = 1; i < elementsLength - 1; i++) {
                    List<Set> elementsi = elements[i];
                    List<Set> otherelementsi = other.elements[i];
                    int elementsiCount = elementsi.Count;
                    for (int j = 0; j < elementsi.Count; j++) {
                        int ans = Math.Sign(elementsi[j].num - otherelementsi[j].num);
                        if (ans != 0)
                            return ans;
                    }
                }
            }

            return 0;
        }



        /// <summary>
        /// Determines equality of topologies.
        /// </summary>
        /// <param name="other">
        /// The topology to compare to.
        /// </param>
        /// <returns>
        /// True if the topologies are equal, false otherwise.
        /// </returns>
        /// <remarks>
        /// Uses CompareTo directly.
        /// </remarks>
        public bool Equals(Topology other) {
            return CompareTo(other) == 0;
        }



        #endregion



        /// <summary>
        /// Produces a formated representation of this topology.
        /// </summary>
        /// <returns>
        /// A string representation of this topology.
        /// </returns>
        /// <remarks>
        /// Applies the minimal permutation in producing the output.
        /// </remarks>
        public override string ToString() {
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < elements.Length; i++) {
                for (int j = 0; j < elements[i].Count; j++) {
                    if (min == 0) {
                        builder.Append(elements[i][j].ToString());
                    }
                    else {
                        builder.Append(powerset.PermuteSet(elements[i][j], min).ToString());
                    }
                }
            }
            builder.AppendFormat(" ({0})", duplicates);
            builder.AppendLine();
            return builder.ToString();
        }

    }
}
